# Redis

## Redis入门

Redis是一个基于内存、K-V模式的NoSQL数据库

Redis不止可以作为数据库，也可以作为消息队列等



### SQL与NoSQL

SQL是一个基于磁盘存储、使用SQL查询并且数据相互关联的结构化数据库

NoSQL是一个基于内存存储、不适用SQL查询并且数据之间无关联的非结构化数据库



### Redis特征

- 
  支持多种数据结构，例如String、Set、SortedSet、List、Hash等

- 单线程，每个命令的执行具备原子性，中途不会执行其他命令（指命令处理始终是单线程的，自 6.x 起改为多线程接受网络请求）

- 高性能、低延时（基于内存、IO 多路复用、良好编码）

- 支持数据持久化

- 支持主从、分片集群

- 支持多语言客户端



### Redis通用命令

- set key value：添加
- get key：查询
- keys pattern：模糊搜索多个 key。性能较差，生产环境（尤其是主节点）不建议使用
- del key：删除
- exists key：判断 key 是否存在
- expire key：设置过期时间
- ttl key：查询剩余存活时间，未设置过期时间则为 -1

> 如果操作Hash类型，需要在命令之前加入h
>
> 例如添加：hget key value



### Redis基本数据结构

#### String



#### Hash



#### Set



#### SortedSet



#### List



#### Redis客户端

Redis主要使用Jedis、Lettuce、Redisson操作

##### Jedis

命令和原生 redis 命令行的命令一致，学习成本最低（注意它是线程不安全的，通常配合连接池使用）

##### Lettuce

Lettuce 和 Spring 兼容最好（Spring Data Redis 默认集成）、基于 Netty 性能最高

##### Redisson

Redisson 提供了和 Java 集合用法一致的分布式集合，适用于更复杂的业务场景。



#### Spring Data Redis

Spring Data 整合封装了一系列数据访问的操作，Spring Data Redis 则是封装了对 Jedis、Lettuce 这两个 Redis 客户端的操作，提供了统一的 RedisTemplate 来操作 Redis。

- redisTemplate.opsForValue()

  返回值类型：ValueOperations

  操作Sting类型

- redisTemplate.opsForHash()

  返回值类型：HashOperations

  操作Hash类型

- redisTemplate.opsForList()

  返回值类型：ListOperations

  操作List类型

- redisTemplate.opsForSet()

  返回值类型：SetOperations

  操作Set类型

- redisTemplate.opsForZSet()

  返回值类型：ZSetOperations

  操作SortedSet类型

> 要在 Spring Data Redis 中使用 Lettuce 线程池的话，要额外引入 apache commons-pool2 依赖。



##### RedisTemplate序列化

RedisTemplate 默认使用 JDK 原生序列化器，可读性差、内存占用大，因此可以用以下两种方式来改变序列化机制：

- 自定义 RedisTemplate，指定 key 和 value 的序列化器
- 使用自带的 StringRedisTemplate，key 和 value 都默认使用 String 序列化器，仅支持写入 String 类型的 key 和 value。因此需要自己将对象序列化成 String 来写入 Redis，从 Redis 读出数据时也要手动反序列化。



## Redis实战

### 缓存

缓存就是临时存放数据的缓冲区

缓存可以在读取之前提前准备好数据，以便于更快读写数据

#### 优点

- 降低后端节点负载
- 提升数据读写性能

#### 缺点

- 额外引入中间件，增大运维成本
- 额外开发和解决缓存带来的问题，增大开发成本
- 需要保证数据一致性



#### 实现

当查询一个数据时，缓存中没有，则去数据库中读取，然后更新到缓存中

若已有缓存，则直接读取



#### 缓存更新策略

##### 主动更新

编写在业务逻辑中，在修改数据库的同时，更新缓存

一致性较好

维护成本高

##### 超时剔除

给缓存数据添加TTL（Time To Live）时间，到期后自动删除缓存，下次查询时更新缓存

一致性一般

维护成本高

##### 内存淘汰

不用自己维护，利用Redis 的内存淘汰机制，当内存不足时自动淘汰部分数据，下次查询时更新缓存

一致性差

维护成本高

> 一般使用主动更新+超时剔除兜底



##### 主动更新缓存的方式

- 以数据库的数据为准，业务层来控制缓存的写入
- 使用现成的数据写入服务，让服务来维护数据库和缓存的一致性，我们只需要写数据即可
- 先更新缓存，通过异步线程定期将缓存的数据持久化到数据库中



##### 数据一致性

在更新数据时，不论先修改数据库还是先删除缓存都不能完全保证数据一致

建议先修改数据库，再删除缓存，这样出现问题的概率更低

<img src="C:\Users\周逸凡\AppData\Roaming\Typora\typora-user-images\image-20240501133634473.png" alt="image-20240501133634473" style="zoom: 50%;" />

<img src="C:\Users\周逸凡\AppData\Roaming\Typora\typora-user-images\image-20240501133702845.png" alt="image-20240501133702845" style="zoom:50%;" />

> 以上操作可以配合延迟双删保证缓存一定被删除



#### 问题

##### 缓存穿透

攻击者可以恶意请求数据库中不存在的数据，从而使得每次查询都要绕过缓存查数据库，增大数据库的压力。

解决方案：

- 缓存空值：比如塞一个空字符串。注意可以给空对象的键过期时间设置短一些，或者在新增数据时强制清除下对应缓存（防止查出来还是 null）

  优点：

  - 实现简单、维护方便

  缺点：

  - 会有额外的内存消耗
  - 可能造成短期的不一致

- 布隆过滤器

  优点：

  - 内存占用较少、没有多余的key

  缺点：

  - 实现复杂
  - 存在误判的可能

- 预防问题的发生

  - 增强对请求数据的校验
  - 增强对数据格式的控制，例如显示数据的位数
  - 增强用户权限校验
  - 通过限流来保护数据库



##### 缓存击穿

又称为热点key失效

就是一个高并发访问并且缓存重建业务较复杂的key突然失效，无数的请求会在瞬间给数据库带来巨大冲击

解决方案：

- 互斥锁：只有一个线程会负责缓存重建，其余线程拿不到锁就等着

  优点：

  - 没有额外的内存消耗
  - 保证了一致性
  - 实现简单

  缺点：

  - 线程需要等待，性能受到影响
  - 会有死锁的风险

- 逻辑过期：key 设置为永不过期，在 value 中记录过期时间，业务中根据这个过期时间来判断缓存是否有效；如果缓存已过期，只有一个线程能抢到锁（然后需要再次判断是否存在缓存），开启独立线程去更新缓存，然后立即返回过期数据；其他抢不到锁的线程也立即返回过期数据，不用等着锁释放。

  优点：

  - 线程无需等待，性能较好

  缺点：

  - 不保证一致性
  - 有额外的内存消耗
  - 实现复杂



##### 缓存雪崩

大量的key同时失效或Redis宕机导致大量数据访问数据库，带来巨大的压力

解决方案：

- 不让key同时失效
  - 给不同的key的TTL添加随机值

- 尽量不让Redis宕机
  - 利用Redis集群提高服务的可用性
- 给缓存业务添加降级限流、多级缓存



##### 缓存预热

即使使用了缓存，第一个访问的用户依然很慢（缓存中没有数据）（如果第一个访问的是老板=寄）

操作方法：

- 定时任务
- 手动触发

实现：

- 用定时任务，每天刷新

> 缓存预热的空间不能太大，需要留给其他数据缓存空间





### 分布式锁

分布式系统或集群模式下多进程可见并且互斥的锁

锁只对单个JVM有效

#### 基本特征

- 多进程（线程）可见（可读）
- 互斥
- 高可用
- 高性能
- 安全性：不能出现死锁



#### 实现方式

##### MySQL实现

利用mysql本身的互斥锁机制

高可用

性能一般

断开连接时自动释放锁

##### Redis实现

利用setnx这种的互斥命令

高可用

高性能

利用锁超时时间，到期释放

##### Zookeeper

利用节点的唯一性和有序性实现互斥

高可用

性能一般

> MySQL 的实现成本相对最低、Redis 性能最高、Zookeeper 可以实现但不推荐使用（zk重点在于保证强一致性而不是性能和高可用性，CP 模型）



#### Redis分布式锁实现

